
--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dream11 Team Predictor</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Favicon -->
    <link rel="icon" href="logo.png" type="image/x-icon">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for modern typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- Marked.js CDN for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas to convert HTML to image for PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Lucide Icons for a modern, futuristic feel -->
    <script src="https://cdn.jsdelivr.net/npm/lucide-dynamic@latest/dist/lucide.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /*
         * --- Custom Styles for Dream11 Predictor (Enhanced) ---
         * This section enhances the Tailwind CSS with a modern, futuristic theme,
         * including a vibrant color palette, subtle animations, and improved
         * responsiveness and UI elements.
         */
        
        /* Basic font and transition settings for the whole page */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.6s ease, color 0.6s ease;
            background-image: radial-gradient(at 0% 0%, hsl(240, 60%, 8%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(260, 50%, 8%) 0%, transparent 50%);
            background-size: 150% 150%;
            background-attachment: fixed;
        }

        /* Defining a vibrant color palette using CSS variables */
        :root {
            /* Light mode colors */
            --bg-color-light: #f3f4f6; /* Light gray */
            --card-bg-light: #ffffff; /* White */
            --text-color-light: #1f2937; /* Dark gray */
            --border-color-light: #e5e7eb; /* Light border gray */
            
            /* Dark mode colors */
            --bg-color-dark: #0a0a0f; /* Deep dark blue-black */
            --card-bg-dark: #13131a; /* Slightly lighter dark blue-black */
            --text-color-dark: #e5e7eb; /* Off-white */
            --border-color-dark: #2d3748; /* Darker blue-gray border */
            
            /* Accent colors for buttons, highlights, etc. */
            --accent-primary: #6366f1; /* Indigo-500 */
            --accent-primary-dark: #818cf8; /* Indigo-400 for dark mode */
            --accent-secondary: #22d3ee; /* Cyan-400 */
            --accent-secondary-dark: #67e8f9; /* Cyan-300 for dark mode */
            --accent-error: #ef4444; /* Red-500 */
            --accent-success: #22c55e; /* Green-500 */
        }
        
        /* Apply colors based on light or dark body class */
        body.light {
            background-color: var(--bg-color-light);
            color: var(--text-color-light);
            background-image: radial-gradient(at 0% 0%, hsl(210, 30%, 95%) 0%, transparent 50%),
                              radial-gradient(at 100% 100%, hsl(200, 20%, 90%) 0%, transparent 50%);
        }

        body.dark {
            background-color: var(--bg-color-dark);
            color: var(--text-color-dark);
        }

        /* Tailwind overrides for dark mode to ensure consistency */
        body.dark .bg-white { background-color: var(--card-bg-dark); }
        body.dark .bg-gray-50 { background-color: #1a1a2e; } /* Darker alternative to bg-gray-50 */
        body.dark .border-gray-100 { border-color: var(--border-color-dark); }
        body.dark .border-gray-200 { border-color: #3f3f46; } /* Deeper gray border */
        body.dark .text-gray-800 { color: var(--text-color-dark); }
        body.dark .text-gray-900 { color: var(--text-color-dark); }
        body.dark .text-gray-600 { color: #a1a1aa; } /* Gray 400 */
        body.dark .text-gray-700 { color: #d4d4d8; } /* Gray 300 */
        body.dark .bg-gray-200 { background-color: #3f3f46; color: #f4f4f5; }
        body.dark .hover\:bg-gray-300:hover { background-color: #52525b; }
        body.dark .bg-gray-100 { background-color: #27272a; }
        body.dark .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.45); }
        body.dark #error-message { background-color: #fee2e2; color: #b91c1c; } /* Light red error for contrast */

        /* Custom styles for glowing effects on buttons and borders */
        .glow-button {
            position: relative;
            z-index: 10;
            transition: all 0.4s ease;
            box-shadow: 0 0 10px var(--accent-primary);
        }
        .glow-button:hover {
            box-shadow: 0 0 15px var(--accent-primary), 0 0 25px var(--accent-primary), 0 0 35px var(--accent-primary);
            transform: translateY(-2px) scale(1.02);
            background-image: linear-gradient(to right, var(--accent-primary), var(--accent-primary-dark));
        }
        body.dark .glow-button {
            box-shadow: 0 0 10px var(--accent-primary-dark);
        }
        body.dark .glow-button:hover {
            box-shadow: 0 0 15px var(--accent-primary-dark), 0 0 25px var(--accent-primary-dark), 0 0 35px var(--accent-primary-dark);
            background-image: linear-gradient(to right, var(--accent-primary-dark), var(--accent-primary));
        }
        
        .glow-border {
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.3); /* Slightly softer glow */
            border: 1px solid rgba(99, 102, 241, 0.2);
            transition: all 0.5s ease;
        }
        body.dark .glow-border {
            box-shadow: 0 0 20px rgba(129, 140, 248, 0.25);
            border: 1px solid rgba(129, 140, 248, 0.15);
        }
        
        /* Markdown content styling for better readability */
        .markdown-content h1, .markdown-content h2, .markdown-content h3 { font-weight: 800; margin-bottom: 0.75em; margin-top: 1.5em; line-height: 1.2; color: var(--accent-primary); }
        body.dark .markdown-content h1, body.dark .markdown-content h2, body.dark .markdown-content h3 { color: var(--accent-primary-dark); }
        .markdown-content h1 { font-size: 2.25rem; }
        .markdown-content h2 { font-size: 1.875rem; }
        .markdown-content h3 { font-size: 1.5rem; }
        .markdown-content ul, .markdown-content ol { list-style-position: inside; margin-left: 1.5em; margin-bottom: 1em; }
        .markdown-content li { margin-bottom: 0.5em; }
        .markdown-content strong { color: var(--accent-secondary); font-weight: 700; }
        body.dark .markdown-content strong { color: var(--accent-secondary-dark); }
        .markdown-content p { margin-bottom: 1em; } /* Ensure paragraphs have spacing */
        .markdown-content p:last-child { margin-bottom: 0; }

        /* Custom styles for dark mode toggle switch */
        .slider {
            background-color: #d1d5db;
            transition: .4s;
        }
        .dark .slider {
            background-color: #4b5563;
        }
        .slider:before {
            background-color: white;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: var(--accent-primary);
        }
        input:checked + .slider:before {
            transform: translateX(24px);
        }

        /* Custom scrollbar for a sleek look */
        #chat-history::-webkit-scrollbar { width: 10px; }
        #chat-history::-webkit-scrollbar-track { background: var(--card-bg-light); border-radius: 5px; }
        #chat-history::-webkit-scrollbar-thumb { background: #888; border-radius: 5px; border: 2px solid var(--card-bg-light); }
        #chat-history::-webkit-scrollbar-thumb:hover { background: #555; }
        .dark #chat-history::-webkit-scrollbar-track { background: var(--card-bg-dark); }
        .dark #chat-history::-webkit-scrollbar-thumb { background: #6b7280; border-color: var(--card-bg-dark); }
        .dark #chat-history::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        
        /* Modern loading animation */
        .loader-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        .loader-dot {
            width: 12px;
            height: 12px;
            margin: 0 4px;
            background-color: var(--accent-primary);
            border-radius: 50%;
            display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .loader-dot:nth-child(1) { animation-delay: -0.32s; }
        .loader-dot:nth-child(2) { animation-delay: -0.16s; }
        .loader-dot:nth-child(3) { animation-delay: 0s; }
        
        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
                opacity: 0.5;
            }
            40% {
                transform: scale(1.0);
                opacity: 1;
            }
        }

        /* Animation for upload cloud icon */
        @keyframes pulse-grow-shrink {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }
        .animate-pulse-grow-shrink {
            animation: pulse-grow-shrink 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        /* Floating Chat Popup styles */
        #chat-popup-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 50;
        }

        /* Floating button style with text and icon */
        #chat-toggle-button {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px; /* full rounded */
            box-shadow: 0 0 10px var(--accent-secondary);
            background-color: var(--accent-secondary);
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
            cursor: pointer;
            border: none;
            animation: pulse-glow 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
        #chat-toggle-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent-secondary), 0 0 25px var(--accent-secondary), 0 0 35px var(--accent-secondary);
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 10px var(--accent-secondary); }
            50% { box-shadow: 0 0 20px var(--accent-secondary), 0 0 30px var(--accent-secondary); }
        }
        
        #chat-popup-window {
            /* Adjusted for better responsiveness */
            width: 100%;
            max-width: 400px;
            height: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            background-color: rgba(255, 255, 255, 0.9); /* Slightly transparent white */
            border-radius: 1.5rem; /* 24px */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(229, 231, 235, 0.7); /* Slightly transparent border */
            transition: all 0.3s ease-in-out;
            transform-origin: bottom right;
            backdrop-filter: blur(8px); /* Frosted glass effect */
            -webkit-backdrop-filter: blur(8px); /* Safari support */
        }

        /* Dark mode specific for the chat popup */
        body.dark #chat-popup-window {
            background-color: rgba(19, 19, 26, 0.9); /* Slightly transparent dark */
            border-color: rgba(45, 55, 72, 0.7);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.45);
        }
        
        /* New classes for animation */
        .chat-hidden {
            opacity: 0;
            transform: scale(0.8);
            visibility: hidden;
            pointer-events: none;
        }
        .chat-visible {
            opacity: 1;
            transform: scale(1);
            visibility: visible;
            pointer-events: auto;
        }

        /* Responsive adjustments for the floating chat */
        @media (max-width: 768px) {
            #chat-popup-container {
                /* On small screens, move the button closer to the corner */
                bottom: 1rem;
                right: 1rem;
            }
            #chat-popup-window {
                /* On small screens, the popup should be bigger */
                bottom: 1rem;
                right: 1rem;
                width: calc(100vw - 2rem);
                max-width: none; /* Override max-width for full screen-ish size */
                height: calc(100vh - 2rem);
            }
            /* Hide text on floating button on smaller screens */
            #chat-toggle-button span:not([data-lucide]) { /* Target the text span */
                display: none;
            }
            #chat-toggle-button {
                padding: 0.75rem; /* Make the button a square */
            }
        }
        
        /* New chat message styles */
        .chat-message {
            margin-bottom: 0.75rem; /* 12px */
            padding: 1rem; /* 16px */
            border-radius: 1.5rem; /* 24px */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            word-break: break-word; /* Ensure long words break */
            transition: all 0.3s ease;
            transform: scale(0.95);
            transform-origin: bottom;
            max-width: 85%;
            position: relative; /* For action buttons */
            padding-bottom: 2.5rem; /* Make space for action buttons */
        }

        .chat-message.user {
            background-color: #e0f2fe; /* Light blue */
            color: #1e40af; /* Dark blue */
            margin-left: auto;
            border-bottom-right-radius: 0.5rem; /* 8px */
            background-image: linear-gradient(to bottom right, #e0f2fe, #bfdbfe); /* Subtle gradient */
        }
        body.dark .chat-message.user {
            background-color: #1a237e; /* Darker blue */
            color: #e0e7ff; /* Lighter blue */
            background-image: linear-gradient(to bottom right, #1a237e, #312e81);
        }

        .chat-message.ai {
            background-color: #f3f4f6; /* Light gray */
            color: #374151; /* Dark gray */
            margin-right: auto;
            border-bottom-left-radius: 0.5rem; /* 8px */
            background-image: linear-gradient(to bottom left, #f3f4f6, #e5e7eb); /* Subtle gradient */
        }
        body.dark .chat-message.ai {
            background-color: #2d3748; /* Darker gray */
            color: #f9fafb; /* Lighter gray */
            background-image: linear-gradient(to bottom left, #2d3748, #475569);
        }

        /* Styling for chat attachments */
        .chat-image {
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            margin-top: 0.5rem;
            display: block;
        }
        .chat-attachment-preview-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 1rem;
            background-color: #e0e7ff; /* Light indigo */
            color: #3730a3; /* Dark indigo */
            font-size: 0.875rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
        }
        body.dark .chat-attachment-preview-item {
            background-color: #3730a3; /* Dark indigo */
            color: #e0e7ff; /* Light indigo */
        }
        .chat-attachment-preview-item .remove-attachment-btn {
            background: none;
            border: none;
            color: #6366f1; /* Indigo */
            cursor: pointer;
            padding: 0.1rem;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        body.dark .chat-attachment-preview-item .remove-attachment-btn {
            color: #a5b4fc; /* Light indigo */
        }
        .chat-attachment-preview-item .remove-attachment-btn:hover {
            background-color: rgba(99, 102, 241, 0.2);
        }
        body.dark .chat-attachment-preview-item .remove-attachment-btn:hover {
            background-color: rgba(165, 180, 252, 0.2);
        }

        /* Styling for the copy message */
        #copy-message {
            position: fixed;
            bottom: 6rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1.5rem;
            background-color: var(--accent-success);
            color: white;
            border-radius: 9999px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease-in-out;
            z-index: 100;
        }

        #copy-message.show {
            opacity: 1;
            visibility: visible;
        }

        /* --- New/Enhanced Styles for Chat AI Responses & Code Blocks --- */
        
        .chat-message .message-content {
            /* This wrapper is to facilitate better styling around markdown content */
            padding: 0; /* Markdown adds its own spacing, so zero here */
            margin: 0;
        }
        
        /* General markdown styling within AI messages */
        .chat-message.ai .message-content p,
        .chat-message.ai .message-content ul,
        .chat-message.ai .message-content ol,
        .chat-message.ai .message-content h1,
        .chat-message.ai .message-content h2,
        .chat-message.ai .message-content h3,
        .chat-message.ai .message-content blockquote {
            margin-bottom: 1em;
        }
        .chat-message.ai .message-content p:last-child,
        .chat-message.ai .message-content ul:last-child,
        .chat-message.ai .message-content ol:last-child,
        .chat-message.ai .message-content blockquote:last-child {
            margin-bottom: 0;
        }
        .chat-message.ai .message-content ul,
        .chat-message.ai .message-content ol {
            padding-left: 1.5em; /* Standard list indent */
        }
        .chat-message.ai .message-content li {
            margin-bottom: 0.5em;
        }
        .chat-message.ai .message-content strong {
            font-weight: bold;
            color: var(--accent-primary); /* Use primary accent for emphasis */
        }
        body.dark .chat-message.ai .message-content strong {
            color: var(--accent-primary-dark);
        }
        .chat-message.ai .message-content em {
            font-style: italic;
        }
        .chat-message.ai .message-content blockquote {
            border-left: 4px solid var(--accent-secondary);
            padding-left: 1em;
            margin-left: 0;
            color: #555;
        }
        body.dark .chat-message.ai .message-content blockquote {
             color: #a1a1aa; /* Gray 400 */
             border-left: 4px solid var(--accent-secondary-dark);
        }

        /* Code block specific styling */
        .code-block-container {
            position: relative;
            background-color: #27272a; /* Dark background for code */
            color: #f8f8f2; /* Light text color for code */
            border-radius: 0.75rem; /* Rounded corners */
            margin-top: 1rem;
            margin-bottom: 1rem;
            overflow: hidden; /* Ensure rounded corners clip content */
            border: 1px solid #3f3f46; /* Subtle border */
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .code-block-container pre {
            margin: 0; /* Remove default margin from pre */
            padding: 1rem;
            overflow-x: auto; /* Horizontal scroll for long lines */
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace; /* Monospaced font */
            font-size: 0.9em;
            line-height: 1.4;
        }

        .code-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #374151; /* Header background */
            color: #d1d5db; /* Header text */
            padding: 0.5rem 1rem;
            border-bottom: 1px solid #4b5563;
            font-size: 0.85em;
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
        }

        .code-block-copy-button {
            background-color: transparent;
            border: none;
            color: #d1d5db;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.85em;
        }
        .code-block-copy-button:hover {
            background-color: #4b5563;
            color: white;
        }
        .code-block-copy-button:active {
            transform: scale(0.95);
        }

        /* Smallest font size for inline code blocks if any */
        .chat-message.ai .message-content code:not(pre > code) {
            background-color: rgba(100, 116, 139, 0.2); /* slategray-200 with transparency */
            border-radius: 0.25rem;
            padding: 0.2em 0.4em;
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.9em;
            color: #5b21b6; /* deep violet for inline code */
        }
        body.dark .chat-message.ai .message-content code:not(pre > code) {
            background-color: rgba(100, 116, 139, 0.4);
            color: #a78bfa; /* violet-400 */
        }

        /* Ensure links are distinguishable */
        .chat-message.ai .message-content a {
            color: var(--accent-primary);
            text-decoration: underline;
            transition: color 0.2s ease;
        }
        .chat-message.ai .message-content a:hover {
            color: #0d47a1; /* Darker blue on hover */
        }
        body.dark .chat-message.ai .message-content a {
            color: #60a5fa; /* Blue-400 */
        }
        body.dark .chat-message.ai .message-content a:hover {
            color: #93c5fd; /* Blue-300 */
        }

        /* Styles for message action buttons (copy/dictate) */
        .message-actions {
            position: absolute;
            bottom: 0.5rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            padding: 0.25rem 0.5rem;
            background-color: rgba(255, 255, 255, 0.6); /* Semi-transparent background */
            border-radius: 0.75rem;
            backdrop-filter: blur(5px); /* Frosted glass effect */
            transition: opacity 0.3s ease;
            opacity: 0; /* Hidden by default */
            z-index: 10;
        }

        .chat-message:hover .message-actions {
            opacity: 1; /* Show on message hover */
        }

        body.dark .message-actions {
            background-color: rgba(0, 0, 0, 0.4);
        }

        .message-actions button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; /* To center icon */
            align-items: center;
            justify-content: center;
        }

        .message-actions button .lucide { /* Target the SVG element directly for color */
            color: #6b7280; /* Gray 500 */
            width: 1rem;
            height: 1rem;
        }
        body.dark .message-actions button .lucide {
            color: #9ca3af; /* Gray 400 */
        }

        .message-actions button:hover .lucide {
            color: #1f2937; /* Gray 900 */
        }
        body.dark .message-actions button:hover .lucide {
            color: #e5e7eb; /* Gray 200 */
        }
        .message-actions button:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }
        body.dark .message-actions button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .chat-message.user .message-actions {
            right: 1rem;
            left: auto;
        }
        .chat-message.ai .message-actions {
            left: 1rem;
            right: auto;
        }

        /* New style for speech recognition button when active */
        .voice-input-active {
            background-color: var(--accent-error) !important; /* Red when recording */
            animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }

        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }

        /* Styles for the hidden PDF export template */
        #pdf-export-content {
            display: none; /* Hidden by default */
            width: 210mm; /* A4 width */
            min-height: 297mm; /* A4 height, ensures at least one page worth of content */
            padding: 20mm; /* Margins */
            box-sizing: border-box; /* Include padding in width/height */
            font-family: 'Inter', sans-serif;
            color: #333;
            background: white;
            flex-direction: column; /* Ensure content flows vertically */
            justify-content: space-between; /* Push header/footer to ends */
        }

        #pdf-export-content .pdf-header {
            text-align: center;
            margin-bottom: 20mm;
            border-bottom: 2px solid #6366f1; /* Indigo */
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        #pdf-export-content .pdf-header h1 {
            font-size: 28px;
            font-weight: bold;
            color: #6366f1; /* Indigo */
            margin: 0;
            line-height: 1;
        }
        #pdf-export-content .pdf-header p {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        #pdf-export-content .pdf-header .lucide {
            width: 32px;
            height: 32px;
            color: #6366f1; /* Indigo */
        }

        #pdf-export-content .pdf-body {
            flex-grow: 1; /* Allow body to take up remaining space */
            font-size: 12px;
            line-height: 1.6;
        }

        #pdf-export-content .pdf-body h1,
        #pdf-export-content .pdf-body h2,
        #pdf-export-content .pdf-body h3 {
            font-weight: bold;
            margin-bottom: 0.5em;
            margin-top: 1em;
            line-height: 1.2;
            color: #6366f1; /* Indigo */
        }
        #pdf-export-content .pdf-body h1 { font-size: 24px; }
        #pdf-export-content .pdf-body h2 { font-size: 20px; }
        #pdf-export-content .pdf-body h3 { font-size: 16px; }
        #pdf-export-content .pdf-body ul,
        #pdf-export-content .pdf-body ol {
            list-style-position: outside; /* Ensure bullets are visible */
            margin-left: 2em;
            margin-bottom: 1em;
            padding: 0;
        }
        #pdf-export-content .pdf-body li {
            margin-bottom: 0.3em;
        }
        #pdf-export-content .pdf-body strong {
            font-weight: bold;
            color: #22c55e; /* Green accent */
        }
        #pdf-export-content .pdf-body a {
            color: #6366f1;
            text-decoration: underline;
        }
        #pdf-export-content .pdf-body blockquote {
            border-left: 4px solid #ccc;
            padding-left: 1em;
            margin-left: 0;
            color: #555;
            font-style: italic;
        }

        /* PDF Code block styling - adjusted for print */
        #pdf-export-content .code-block-container {
            background-color: #f8f8f2; /* Lighter background for print */
            color: #333;
            border-radius: 0.5rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
            overflow: hidden;
            border: 1px solid #ddd;
            box-shadow: none; /* No shadows in PDF */
        }
        #pdf-export-content .code-block-container pre {
            padding: 0.8rem;
            font-size: 10px;
            line-height: 1.3;
        }
        #pdf-export-content .code-block-header {
            background-color: #eee;
            color: #555;
            padding: 0.4rem 0.8rem;
            border-bottom: 1px solid #ddd;
            font-size: 0.8em;
            display: flex; /* Re-enable flex for header elements like language */
            justify-content: space-between;
            align-items: center;
        }
        #pdf-export-content .code-block-copy-button { /* Hide copy button in PDF */
            display: none;
        }
        #pdf-export-content .pdf-footer {
            text-align: center;
            margin-top: 20mm;
            border-top: 1px solid #eee;
            padding-top: 10px;
            font-size: 10px;
            color: #999;
        }

        /* Chat action buttons dropdown */
        .chat-actions-dropdown {
            position: absolute;
            bottom: calc(100% + 8px); /* Position above the input bar */
            right: 0; /* Align with the parent's right edge */
            background-color: var(--card-bg-light);
            border-radius: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            transform-origin: bottom right;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
            z-index: 20;
            border: 1px solid var(--border-color-light);
            min-width: 140px; /* Adjust as needed */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        body.dark .chat-actions-dropdown {
            background-color: var(--card-bg-dark);
            border-color: var(--border-color-dark);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .chat-actions-dropdown.hidden {
            opacity: 0;
            transform: scale(0.9);
            pointer-events: none;
        }
        .chat-actions-dropdown button,
        .chat-actions-dropdown label {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-radius: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: var(--text-color-light); /* Default text color */
        }
        body.dark .chat-actions-dropdown button,
        body.dark .chat-actions-dropdown label {
            color: var(--text-color-dark);
        }
        .chat-actions-dropdown button:hover,
        .chat-actions-dropdown label:hover {
            background-color: var(--bg-color-light); /* Lighter hover for light theme */
        }
        body.dark .chat-actions-dropdown button:hover,
        body.dark .chat-actions-dropdown label:hover {
            background-color: #1a1a2e; /* Darker hover for dark theme */
        }
        .chat-actions-dropdown button .lucide,
        .chat-actions-dropdown label .lucide {
            margin-right: 0.5rem;
            width: 1.25rem;
            height: 1.25rem;
            flex-shrink: 0;
            color: var(--accent-primary); /* Use primary accent for icons */
        }
        body.dark .chat-actions-dropdown button .lucide,
        body.dark .chat-actions-dropdown label .lucide {
            color: var(--accent-primary-dark);
        }

        /* Drag and Drop visual feedback for chat window */
        #chat-popup-window.drag-over-active {
            border: 2px dashed var(--accent-primary);
            box-shadow: 0 0 20px var(--accent-primary), 0 0 30px var(--accent-primary) inset;
        }
        body.dark #chat-popup-window.drag-over-active {
            border: 2px dashed var(--accent-primary-dark);
            box-shadow: 0 0 20px var(--accent-primary-dark), 0 0 30px var(--accent-primary-dark) inset;
        }

    </style>
</head>
<body class="antialiased dark">

    <!-- Main container with fluid padding for responsiveness -->
    <div class="container mx-auto p-4 md:p-8 lg:p-12 min-h-screen flex items-start justify-center">
        <div class="bg-white rounded-3xl shadow-2xl p-6 md:p-10 lg:p-12 border border-gray-100 transition-colors duration-300 w-full max-w-6xl glow-border">
            
            <!-- Header Section with Dark Mode Toggle -->
            <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-10">
                <div class="text-left mb-4 md:mb-0">
                    <h1 class="text-4xl md:text-5xl lg:text-6xl font-extrabold text-gray-900 tracking-tight">
                        Dream11 Predictor <span class="text-indigo-500">âš¡</span>
                    </h1>
                    <p class="text-lg md:text-xl text-gray-600 mt-2">
                        Analyze data and craft your winning team with AI.
                    </p>
                </div>
                <div class="flex items-center space-x-2 mt-4 md:mt-0">
                    <span class="text-gray-500 text-sm">Light</span>
                    <label class="switch relative inline-block w-14 h-8">
                        <input type="checkbox" id="dark-mode-toggle" class="opacity-0 w-0 h-0">
                        <span class="slider absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-6 before:w-6 before:left-1 before:bottom-1 before:rounded-full"></span>
                    </label>
                    <span class="text-gray-500 text-sm">Dark</span>
                </div>
            </div>

            <!-- Disclaimer for Fantasy Sports Risks -->
            <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-6 rounded-md" role="alert">
                <p class="font-bold">Disclaimer:</p>
                <p class="text-sm">Fantasy sports involve an element of financial risk and may be addictive. Please play responsibly and at your own risk. The predictions and advice provided by this AI are based on available data and are for informational purposes only. They do not guarantee financial winnings or success in fantasy contests.</p>
            </div>


            <!-- Main Content Area with responsive columns -->
            <div class="flex flex-col gap-8">
                <!-- Prediction Output -->
                <div class="flex-1">
                    
                    <!-- Upload and Preview Section -->
                    <div id="upload-area" class="bg-gray-50 rounded-2xl p-6 sm:p-8 mb-4 border-2 border-dashed border-gray-200 transition-all duration-300 hover:bg-gray-100 hover:border-indigo-400">
                        <label for="image-upload" class="cursor-pointer block">
                            <div class="flex flex-col items-center justify-center p-4 sm:p-6 text-center">
                                <span data-lucide="upload-cloud" class="w-12 h-12 sm:w-14 sm:h-14 text-indigo-500 animate-pulse-grow-shrink"></span>
                                <p class="mt-4 text-sm text-gray-600">
                                    <span class="font-semibold text-indigo-600 hover:text-indigo-700 transition-colors">
                                        Click to upload
                                    </span>
                                    or drag and drop your image(s)
                                </p>
                                <p class="text-xs text-gray-500 mt-1">PNG, JPG up to 10MB per image</p>
                            </div>
                        </label>
                        <input type="file" id="image-upload" accept="image/*" class="hidden" multiple>
                        <p class="text-xs text-gray-500 mt-4 text-center">
                            <span data-lucide="info" class="w-4 h-4 inline-block align-text-bottom mr-1"></span> For best predictions, upload screenshots with player stats, recent form, team news, and pitch reports.
                        </p>
                    </div>

                    <div id="preview-container" class="mb-4 hidden transition-opacity duration-300">
                        <h2 class="text-lg sm:text-xl font-bold mb-4 text-gray-700 dark:text-gray-300">Image Preview(s):</h2>
                        <div id="image-previews" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                            <!-- Image previews will be dynamically added here -->
                        </div>
                    </div>

                    <!-- Action and Status Buttons -->
                    <div class="flex flex-col sm:flex-row gap-4 mb-8">
                        <button id="analyze-btn" class="flex-1 py-3 px-6 sm:py-4 sm:px-8 rounded-full bg-indigo-600 text-white font-bold shadow-lg focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-300 disabled:bg-indigo-400 disabled:cursor-not-allowed transform hover:scale-105 glow-button" style="--accent-primary: #6366f1; --accent-primary-dark: #818cf8;">
                            Analyze and Predict
                        </button>
                        <button id="clear-btn" class="flex-1 py-3 px-6 sm:py-4 sm:px-8 rounded-full bg-gray-200 text-gray-800 font-bold shadow-lg hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600 focus:outline-none focus:ring-4 focus:ring-gray-400 transition-all duration-300 transform hover:scale-105">
                            Clear All
                        </button>
                    </div>

                    <!-- AI Response Section -->
                    <div id="results-container" class="hidden transition-opacity duration-300">
                        <h2 class="text-xl sm:text-2xl font-bold mb-4 text-gray-700 dark:text-gray-300 border-b-2 border-indigo-500 dark:border-indigo-400 pb-2">AI's Dream11 Prediction:</h2>
                        <div id="loading-indicator" class="hidden text-center text-gray-500 text-sm py-8">
                             <!-- Modern loader animation -->
                             <div class="loader-container">
                                <div class="loader-dot"></div>
                                <div class="loader-dot"></div>
                                <div class="loader-dot"></div>
                             </div>
                            <span class="mt-4 block">Analyzing the image(s) and generating the team...</span>
                        </div>
                        <div id="error-message" class="hidden bg-red-100 border border-red-400 text-red-700 px-6 py-4 rounded-xl relative shadow-md" role="alert">
                            <span class="block sm:inline" id="error-text"></span>
                        </div>
                        <div id="prediction-output" class="p-6 bg-gray-100 rounded-xl border border-gray-200 text-base shadow-inner markdown-content dark:bg-gray-800 dark:border-gray-700"></div>
                        
                        <!-- New buttons for PDF and Text Export -->
                        <div id="export-buttons" class="mt-4 flex flex-col sm:flex-row gap-4 hidden">
                            <button id="save-pdf-btn" class="flex-1 py-3 px-6 sm:py-4 sm:px-8 rounded-full bg-green-500 text-white font-bold shadow-lg hover:bg-green-600 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-300 transform hover:scale-105">
                                <span data-lucide="file-text" class="w-5 h-5 mr-2 inline-block"></span> Save as PDF
                            </button>
                            <button id="share-text-btn" class="flex-1 py-3 px-6 sm:py-4 sm:px-8 rounded-full bg-blue-500 text-white font-bold shadow-lg hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-300 transform hover:scale-105">
                                <span data-lucide="share-2" class="w-5 h-5 mr-2 inline-block"></span> Share as Text
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Floating Chat Popup -->
    <div id="chat-popup-container">
        <!-- Floating button to open the chat -->
        <button id="chat-toggle-button" class="group">
            <span data-lucide="message-square" class="w-6 h-6 text-white transition-transform duration-300 group-hover:rotate-12"></span>
            <span class="ml-2">Chat with AI</span>
        </button>

        <!-- The actual chat popup window -->
        <div id="chat-popup-window" class="chat-hidden fixed bottom-24 right-4 md:right-8 lg:right-12 flex-col">
            <!-- Header for the chat popup -->
            <div class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700 rounded-t-2xl bg-gray-50 dark:bg-gray-800">
                <h2 class="text-lg font-bold text-gray-800 dark:text-gray-200">Chat with AI</h2>
                <button id="chat-close-button" aria-label="Close Chat" class="text-gray-500 hover:text-gray-900 dark:hover:text-white transition-colors p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
                    <span data-lucide="x" class="w-6 h-6"></span>
                </button>
            </div>
            
            <!-- Chat history div with a minimum height and scroll -->
            <div id="chat-history" class="p-4 overflow-y-auto flex-1 flex flex-col">
                <!-- Chat messages will be appended here -->
            </div>
            
            <!-- Chat input section with attachment, voice and send button -->
            <div class="p-4 border-t border-gray-200 dark:border-gray-700 relative">
                <!-- Attachment preview -->
                <div id="chat-attachments-preview-container" class="mb-2 flex flex-wrap items-center gap-2 hidden">
                    <!-- Attachments previews will be dynamically added here -->
                </div>

                <!-- Dropdown for attachment/voice buttons -->
                <div id="chat-actions-dropdown" class="chat-actions-dropdown hidden">
                    <button id="voice-input-btn" class="w-full justify-start text-left">
                        <span data-lucide="mic" class="w-5 h-5"></span> Voice Input
                    </button>
                    <label for="chat-image-upload" class="w-full justify-start text-left">
                        <span data-lucide="paperclip" class="w-5 h-5"></span> Attach File
                    </label>
                    <input type="file" id="chat-image-upload" accept="image/*, .txt, .pdf, .csv, .json, .xml, .md" class="hidden" multiple>
                </div>

                <div class="flex gap-2 items-end">
                    <input type="text" id="chat-input" class="flex-1 p-3 rounded-full border border-gray-300 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-colors shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Ask a follow-up question...">
                    
                    <button id="add-chat-attachment-btn" aria-label="Add attachment or voice input" class="flex items-center justify-center w-12 h-12 rounded-full bg-gray-200 text-gray-600 dark:bg-gray-700 dark:text-gray-200 shadow-lg hover:bg-gray-300 dark:hover:bg-gray-600 cursor-pointer transition-all duration-300 flex-shrink-0">
                        <span data-lucide="plus" class="w-5 h-5"></span>
                    </button>

                    <button id="send-chat-btn" aria-label="Send Message" class="flex items-center justify-center w-12 h-12 rounded-full bg-indigo-600 text-white shadow-lg focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-300 disabled:bg-indigo-400 disabled:cursor-not-allowed glow-button flex-shrink-0" style="--accent-primary: #6366f1; --accent-primary-dark: #818cf8;">
                        <span data-lucide="send" class="w-5 h-5"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Temporary message for clipboard copy -->
    <div id="copy-message">Text copied to clipboard!</div>

    <!-- Hidden div for PDF export template -->
    <div id="pdf-export-content" style="display: none;">
        <div class="pdf-header">
            <span data-lucide="trophy" class="w-8 h-8"></span>
            <h1>Dream11 Team Prediction</h1>
            <p>Generated on <span id="pdf-date"></span></p>
        </div>
        <div class="pdf-body">
            <!-- Prediction output will be inserted here -->
        </div>
        <div class="pdf-footer">
            Powered by Gemini AI | Dream11 Predictor
        </div>
    </div>


    <script type="text/javascript">
        // Register Service Worker for PWA capabilities
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        // JavaScript for handling image upload, API call, and chat functionality
        
        // This function call is from the Lucide Icon library to replace all `<span>` tags with the corresponding SVG icons
        // It should be called any time new Lucide icon elements are added to the DOM.
        const createIcons = () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        };

        window.addEventListener('load', () => {
             // Create icons on initial page load for the main UI
             createIcons();
        });

        const uploadArea = document.getElementById('upload-area');
        const imageUpload = document.getElementById('image-upload');
        const imagePreviewsContainer = document.getElementById('image-previews'); 
        const previewContainer = document.getElementById('preview-container');
        const analyzeBtn = document.getElementById('analyze-btn');
        const clearBtn = document.getElementById('clear-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const resultsContainer = document.getElementById('results-container');
        const predictionOutput = document.getElementById('prediction-output');
        const exportButtons = document.getElementById('export-buttons');
        const savePdfBtn = document.getElementById('save-pdf-btn');
        const shareTextBtn = document.getElementById('share-text-btn');
        const errorContainer = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        
        // Dark Mode elements
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        
        // Chat elements
        const chatToggleButton = document.getElementById('chat-toggle-button');
        const chatPopupWindow = document.getElementById('chat-popup-window');
        const chatCloseButton = document.getElementById('chat-close-button');
        const chatHistoryDiv = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
        const chatImageUpload = document.getElementById('chat-image-upload');
        const chatAttachmentsPreviewContainer = document.getElementById('chat-attachments-preview-container'); 
        const voiceInputBtn = document.getElementById('voice-input-btn');
        const addChatAttachmentBtn = document.getElementById('add-chat-attachment-btn'); // New plus button
        const chatActionsDropdown = document.getElementById('chat-actions-dropdown'); // New dropdown div
        
        // Copy message element
        const copyMessage = document.getElementById('copy-message');

        // PDF Export template elements
        const pdfExportContent = document.getElementById('pdf-export-content');
        const pdfBody = pdfExportContent.querySelector('.pdf-body');
        const pdfDate = document.getElementById('pdf-date');

        let uploadedMainImages = []; // Array to store {mimeType, data, file} for main upload
        let chatAttachments = []; // Array to store {file: File, mimeType: string, data: string} for chat
        let chatHistory = [];
        let lastPredictionText = '';

        // Web Speech API related variables
        let currentUtterance = null;
        let isSpeaking = false;
        let messageTextCache = new Map(); // Store message content for copy/dictate

        // Speech Recognition variables
        let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let isVoiceInputActive = false;
        let finalTranscript = ''; // Stores the accumulated final transcript for speech input

        // Initialize SpeechRecognition if available
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true; // Keep listening for multiple phrases
            recognition.interimResults = true; // Show results while speaking
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isVoiceInputActive = true;
                voiceInputBtn.classList.add('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic-off', 'w-5 h-5'); // Change icon to indicate listening in dropdown
                chatInput.placeholder = 'Listening... Speak now.';
                finalTranscript = ''; // Clear previous transcript for a new session
                chatInput.value = ''; // Clear input field
                chatActionsDropdown.classList.add('hidden'); // Hide dropdown when voice input starts
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript + ' '; // Add space for readability
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                chatInput.value = finalTranscript + interimTranscript; // Update input with current recognition
                chatInput.scrollLeft = chatInput.scrollWidth; // Scroll to end
            };

            recognition.onend = () => {
                isVoiceInputActive = false;
                voiceInputBtn.classList.remove('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5'); // Reset icon to mic in dropdown
                chatInput.placeholder = 'Ask a follow-up question...';

                // If there's a final transcript, populate the input field.
                if (finalTranscript.trim() !== '') {
                    chatInput.value = finalTranscript.trim(); // Ensure final transcript is in the input
                } else if (chatInput.value.trim() === '') {
                    // If recognition ended with no final transcript and input is empty, clear it
                    chatInput.value = ''; 
                }
            };

            recognition.onerror = (event) => {
                isVoiceInputActive = false; // Important: reset state on error
                voiceInputBtn.classList.remove('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5'); // Reset icon
                chatInput.placeholder = 'Ask a follow-up question...';
                chatActionsDropdown.classList.add('hidden'); // Hide dropdown on error too

                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone access denied. Please allow microphone access in your browser settings.');
                } else if (event.error === 'no-speech') {
                    console.log('No speech detected, recognition ended.');
                    if (finalTranscript.trim() === '') {
                        chatInput.value = '';
                    }
                } else if (event.error === 'network') {
                    showError('Speech recognition network error. This often means a firewall, proxy, or browser extension is blocking access to Google\'s speech services. Please try disabling extensions or testing in incognito mode.');
                } else {
                    showError(`Speech recognition error: ${event.error}`);
                }
            };
            
            // Optional: Listen for audio start/end for more granular control/feedback
            recognition.onaudiostart = () => {
                // console.log('Audio capturing started.');
            };

            recognition.onaudioend = () => {
                // console.log('Audio capturing ended.');
            };

        } else {
            console.warn('Web Speech API (SpeechRecognition) not supported in this browser. Voice input button will be hidden.');
            voiceInputBtn.style.display = 'none'; // Hide the voice input button if not supported
        }

        // Dark Mode Initialization and Listener
        // Set dark mode as default if not already set in local storage
        if (localStorage.getItem('dark-mode') === null) {
            localStorage.setItem('dark-mode', 'true');
        }
        
        const isDarkMode = localStorage.getItem('dark-mode') === 'true';
        if (isDarkMode) {
            document.body.classList.add('dark');
            darkModeToggle.checked = true;
        } else {
            document.body.classList.remove('dark');
            darkModeToggle.checked = false;
        }

        darkModeToggle.addEventListener('change', () => {
            if (darkModeToggle.checked) {
                document.body.classList.add('dark');
                localStorage.setItem('dark-mode', 'true');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem('dark-mode', 'false');
            }
        });

        // Function to convert a file to a Base64 string and return its MIME type and data
        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve({
                    mimeType: file.type || 'application/octet-stream', // Fallback MIME type
                    data: reader.result.split(',')[1]
                });
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        };

        // Function to get Lucide icon name based on MIME type
        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return 'image';
            if (mimeType === 'application/pdf') return 'file-text';
            if (mimeType.includes('text/')) return 'file-text';
            if (mimeType.includes('csv') || mimeType.includes('excel')) return 'file-spreadsheet';
            if (mimeType.includes('json') || mimeType.includes('xml') || mimeType.includes('code') || mimeType.includes('markdown')) return 'file-code';
            return 'file';
        }

        // Function to display an error message
        function showError(message) {
            errorText.textContent = message;
            errorContainer.classList.remove('hidden');
        }
        
        // --- Marked.js Custom Renderer for Code Blocks ---
        const renderer = {
            code(code, lang) {
                let actualCodeContent;
                if (typeof code === 'object' && code !== null && typeof code.text === 'string') {
                    actualCodeContent = code.text;
                } else if (typeof code !== 'string') {
                    actualCodeContent = String(code);
                } else {
                    actualCodeContent = code;
                }

                const languageDisplay = lang ? `<span class="text-xs font-semibold uppercase text-gray-400">${lang}</span>` : '';
                const uniqueId = `code-block-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                const escapedCode = actualCodeContent.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');

                return `
                    <div class="code-block-container">
                        <div class="code-block-header">
                            ${languageDisplay}
                            <button class="code-block-copy-button" data-copy-target="${uniqueId}">
                                <span data-lucide="clipboard" class="w-4 h-4"></span>
                                Copy code
                            </button>
                        </div>
                        <pre><code id="${uniqueId}">${escapedCode}</code></pre>
                    </div>
                `;
            }
        };

        marked.use({ renderer });

        /**
         * Helper function to update a Lucide icon displayed within a button.
         * Removes the existing SVG and adds a new span for Lucide to convert.
         * @param {HTMLElement} buttonElement The button element containing the icon.
         * @param {string} newIconName The Lucide icon name (e.g., 'check', 'clipboard').
         * @param {string} [classList] Optional additional classes for the new span. Defaults to 'w-4 h-4' for action buttons.
         */
        function updateButtonIcon(buttonElement, newIconName, classList = 'w-4 h-4') {
            // Remove existing Lucide SVG (it will have the 'lucide' class)
            let currentIconSvg = buttonElement.querySelector('.lucide');
            if (currentIconSvg) {
                currentIconSvg.remove();
            }

            // Create a new span element
            const newIconSpan = document.createElement('span');
            newIconSpan.setAttribute('data-lucide', newIconName);
            newIconSpan.className = classList; // Apply styling classes

            // Append the new span to the button
            buttonElement.appendChild(newIconSpan);
           
            createIcons(); // Trigger Lucide to convert the new span to SVG
        }


        // Function to append a message to the chat history
        function appendChatMessage(role, text, attachments = []) { // removed generatedImage parameter
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message', role);
            
            // Unique ID for the message to reference its content
            const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            messageDiv.dataset.messageId = messageId;
            
            let contentHTML = '';
            let rawMessageContentForCache = ''; // To store plain text for copy/dictate

            if (role === 'user') {
                rawMessageContentForCache = `You: ${text}`;
                contentHTML += `<span class="font-bold">You:</span> ${text}`;
                if (attachments.length > 0) {
                    contentHTML += `<div class="mt-2 flex flex-wrap gap-2">`;
                    attachments.forEach(attachment => {
                        if (attachment.mimeType.startsWith('image/')) {
                            contentHTML += `<img src="data:${attachment.mimeType};base64,${attachment.data}" alt="${attachment.name || 'User attachment'}" class="chat-image w-24 h-24 object-cover">`;
                        } else {
                            // For non-image files, display an icon and file name
                            contentHTML += `
                                <div class="flex items-center space-x-1 p-2 bg-gray-100 dark:bg-gray-600 rounded-md text-sm">
                                    <span data-lucide="${getFileIcon(attachment.mimeType)}" class="w-4 h-4 flex-shrink-0"></span>
                                    <span class="truncate max-w-[120px]">${attachment.name || 'File'}</span>
                                </div>
                            `;
                        }
                    });
                    contentHTML += `</div>`;
                    // Add attachment info to raw content
                    rawMessageContentForCache += `\n[Attachments: ${attachments.map(a => a.name).join(', ')}]`;
                }
            } else { // AI message
                rawMessageContentForCache = `AI: ${text}`;
                // Render markdown content within a wrapper for better styling control
                contentHTML = `<div class="message-content">${marked.parse(text)}</div>`;
            }
            
            // Set the raw text in cache, accounting for actual content for dictation
            messageTextCache.set(messageId, rawMessageContentForCache); 

            // Add action buttons
            const actionsHTML = `
                <div class="message-actions">
                    <button class="copy-message-btn" title="Copy message" data-message-id="${messageId}">
                        <span data-lucide="clipboard" class="w-4 h-4"></span>
                    </button>
                    <button class="dictate-message-btn" title="Dictate message" data-message-id="${messageId}">
                        <span data-lucide="volume-2" class="w-4 h-4"></span>
                    </button>
                </div>
            `;
            
            messageDiv.innerHTML = contentHTML + actionsHTML;
            chatHistoryDiv.appendChild(messageDiv);
            
            // Animate message pop-in
            setTimeout(() => {
                messageDiv.style.transform = 'scale(1)';
            }, 10);
            
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            // Call createIcons() after adding new content to the chat history
            createIcons();
        }

        // Function to display main image previews
        function displayMainImagePreviews() {
            imagePreviewsContainer.innerHTML = '';
            if (uploadedMainImages.length > 0) {
                previewContainer.classList.remove('hidden');
                uploadedMainImages.forEach((image, index) => {
                    const previewItem = document.createElement('div');
                    previewItem.classList.add('relative', 'w-full', 'h-48', 'rounded-xl', 'overflow-hidden', 'shadow-lg', 'border', 'border-gray-200');
                    previewItem.innerHTML = `
                        <img src="${URL.createObjectURL(image.file)}" alt="Image Preview" class="w-full h-full object-contain">
                        <button class="absolute top-2 right-2 p-1 bg-red-500 text-white rounded-full opacity-80 hover:opacity-100 transition-opacity remove-main-image-btn" data-index="${index}">
                            <span data-lucide="x" class="w-4 h-4"></span>
                        </button>
                    `;
                    imagePreviewsContainer.appendChild(previewItem);
                });
                createIcons(); // Ensure delete icons are rendered
            } else {
                previewContainer.classList.add('hidden');
            }
        }

        // Event listener for main image upload input
        imageUpload.addEventListener('change', async (event) => {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                uploadedMainImages = []; // Reset array
                
                // Process each file
                for (const file of files) {
                    try {
                        const { mimeType, data } = await fileToBase64(file);
                        uploadedMainImages.push({ file, mimeType, data });

                    } catch (error) {
                        showError(`Failed to read file ${file.name}.`);
                        console.error('File read error:', error);
                    }
                }
                displayMainImagePreviews(); // Update previews
                
                analyzeBtn.disabled = uploadedMainImages.length === 0;
                resultsContainer.classList.add('hidden'); // Hide previous results
                exportButtons.classList.add('hidden'); // Hide export buttons
                errorContainer.classList.add('hidden'); // Hide any previous errors
                chatHistory = []; // Clear chat history
                chatHistoryDiv.innerHTML = '';
                messageTextCache.clear(); // Clear message text cache
                chatToggleButton.classList.remove('hidden'); // Keep the chat button visible
                chatPopupWindow.classList.add('chat-hidden'); // Ensure chat popup is hidden on new main upload
            } else {
                previewContainer.classList.add('hidden');
                analyzeBtn.disabled = true;
                uploadedMainImages = [];
                displayMainImagePreviews(); // Clear previews if no files selected
            }
        });

        // Event listener for removing main image previews (using event delegation)
        imagePreviewsContainer.addEventListener('click', (event) => {
            const removeBtn = event.target.closest('.remove-main-image-btn');
            if (removeBtn) {
                const index = parseInt(removeBtn.dataset.index);
                uploadedMainImages.splice(index, 1); // Remove from array
                displayMainImagePreviews(); // Re-render previews
                analyzeBtn.disabled = uploadedMainImages.length === 0;
            }
        });

        // Event listener for drag & drop on main upload area
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadArea.classList.add('border-indigo-600', 'bg-indigo-50');
            uploadArea.classList.remove('hover:border-indigo-400');
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadArea.classList.remove('border-indigo-600', 'bg-indigo-50');
            uploadArea.classList.add('hover:border-indigo-400');
        });

        uploadArea.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadArea.classList.remove('border-indigo-600', 'bg-indigo-50');
            uploadArea.classList.add('hover:border-indigo-400');

            const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
            if (files.length > 0) {
                uploadedMainImages = []; 
                for (const file of files) {
                    try {
                        const { mimeType, data } = await fileToBase64(file);
                        uploadedMainImages.push({ file, mimeType, data });
                    } catch (error) {
                        showError(`Failed to read file ${file.name}.`);
                        console.error('File read error:', error);
                    }
                }
                displayMainImagePreviews();
                analyzeBtn.disabled = uploadedMainImages.length === 0;
                resultsContainer.classList.add('hidden');
                exportButtons.classList.add('hidden');
                errorContainer.classList.add('hidden');
                chatHistory = [];
                chatHistoryDiv.innerHTML = '';
                messageTextCache.clear();
                chatToggleButton.classList.remove('hidden');
                chatPopupWindow.classList.add('chat-hidden');
            }
        });

        // Event listener for the Analyze button
        analyzeBtn.addEventListener('click', async () => {
            if (uploadedMainImages.length === 0) {
                showError('Please upload at least one image first.');
                return;
            }
            
            // Show loading state
            loadingIndicator.classList.remove('hidden');
            analyzeBtn.disabled = true;
            resultsContainer.classList.remove('hidden');
            predictionOutput.innerHTML = '';
            exportButtons.classList.add('hidden');
            errorContainer.classList.add('hidden');
            
            // Hide the chat popup and show button during analysis for clarity
            chatToggleButton.classList.remove('hidden'); 
            chatPopupWindow.classList.add('chat-hidden'); 

            // Modified prompt to include guidance for better predictions AND strategic advice
            const initialPrompt = `Act as a professional sports analyst for the fantasy sports platform Dream11, specializing in cricket. You are given a screenshot(s) containing information about an upcoming cricket match.
            
            **Your Task:** Analyze all the text and images within the screenshot(s) to find key details such as player form, team news, pitch conditions, recent performances, and historical data. Based on your thorough analysis, provide the best possible Dream11 team, including a captain and vice-captain.
            
            **Output Format:** Your output must be a single, well-structured text block that:
            1.  Lists the suggested Dream11 team by player role (Wicket-keeper, Batsmen, All-rounders, Bowlers), ensuring a balanced team.
            2.  Provides a concise, point-form analysis explaining your choices for each key player and overall team composition. This analysis must be grounded in the data you extracted from the image.
            3.  Suggests alternative players if options are available and reasons for them.
            4.  Clearly highlights your Captain and Vice-Captain picks with justifications.
            5.  Uses clear headings for each section (e.g., ## Team Analysis) and bullet points for lists (e.g., - Player Name).
            6.  **IMPORTANT:** If you provide any code (e.g., HTML, JavaScript), always wrap it in a markdown code block (e.g., \`\`\`html\n<p>Hello</p>\n\`\`\` or \`\`\`javascript\nconsole.log('hi');\n\`\`\`).
            
            **Information Clarity:**
            - If any crucial information (like specific player stats, team news, or detailed pitch reports) is missing or unclear in the image(s), you must explicitly state what information you were unable to retrieve and how this might impact the prediction.
            
            **Concluding Tips:** Conclude your response with a small section titled '### Tips for Maximizing Fantasy Points' advising the user on what kind of information helps you make more accurate predictions and strategic choices. This section should list:
            - **Comprehensive Player Statistics:** Recent scores, wickets, economy rates, strike rates, fantasy points history.
            - **Detailed Player Form:** Performance in last 5-10 matches, against specific opposition, and at the venue.
            - **Team News & Dynamics:** Injuries, definite lineup changes, team's recent form, batting order, and specific roles (e.g., powerplay bowler, death bowler).
            - **In-depth Pitch Reports:** Batting/bowling friendly, average scores, presence of dew, historical venue performance, and expected behavior throughout the match.
            - **Head-to-Head Records:** Team vs. team and individual player vs. player matchups.
            - **Strategic Advice:** Considerations for grand leagues vs. small leagues (e.g., differential picks, safe vs. risky captains), budget management, and understanding player roles for point optimization.
            
            This will help the user provide better inputs and formulate stronger strategies in the future.`;


            try {
                // Build the user parts for the initial image upload
                const userParts = [{ text: initialPrompt }];
                uploadedMainImages.forEach(img => {
                    userParts.push({
                        inlineData: {
                            mimeType: img.mimeType,
                            data: img.data
                        }
                    });
                });
                
                const payload = {
                    contents: [
                        { role: "user", parts: userParts }
                    ],
                };
                
                const responseText = await callGeminiAPI(payload);
                
                // Store the raw text for sharing
                lastPredictionText = responseText;

                // Render the AI response text using Marked.js for display
                predictionOutput.innerHTML = marked.parse(responseText);
                
                // Store the full, correctly formatted API history
                chatHistory = [
                    { role: 'user', parts: userParts },
                    { role: 'model', parts: [{ text: responseText }] }
                ];
                
                // After analysis, show the chat and export buttons
                chatToggleButton.classList.remove('hidden');
                exportButtons.classList.remove('hidden');
                // The main prediction output is also considered the first AI chat message
                appendChatMessage('ai', responseText); 
                chatInput.focus();

            } catch (error) {
                console.error('Initial API call failed:', error);
                showError(`An error occurred: ${error.message}`);
            } finally {
                loadingIndicator.classList.add('hidden');
                analyzeBtn.disabled = false;
            }
        });
        
        // Event listener for chat image/file upload
        chatImageUpload.addEventListener('change', async (event) => {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                for (const file of files) {
                    try {
                        const { mimeType, data } = await fileToBase64(file);
                        chatAttachments.push({ file, mimeType, data, name: file.name });
                    } catch (error) {
                        showError(`Failed to read chat file ${file.name}.`);
                        console.error('Chat file read error:', error);
                    }
                }
                displayChatAttachments();
                chatInput.focus();
            }
            chatActionsDropdown.classList.add('hidden'); // Hide dropdown after selection
        });

        // Function to display chat attachments
        function displayChatAttachments() {
            chatAttachmentsPreviewContainer.innerHTML = '';
            if (chatAttachments.length > 0) {
                chatAttachmentsPreviewContainer.classList.remove('hidden');
                chatAttachments.forEach((attachment, index) => {
                    const attachmentDiv = document.createElement('div');
                    attachmentDiv.classList.add('chat-attachment-preview-item');
                    attachmentDiv.dataset.index = index;

                    let previewContent = '';
                    if (attachment.mimeType.startsWith('image/')) {
                        previewContent = `<img src="data:${attachment.mimeType};base64,${attachment.data}" alt="${attachment.name}" class="w-8 h-8 object-cover rounded-md">`;
                    } else {
                        previewContent = `<span data-lucide="${getFileIcon(attachment.mimeType)}" class="w-5 h-5 flex-shrink-0"></span>`;
                    }

                    attachmentDiv.innerHTML = `
                        ${previewContent}
                        <span class="truncate max-w-[100px]">${attachment.name}</span>
                        <button class="remove-attachment-btn">
                            <span data-lucide="x" class="w-4 h-4"></span>
                        </button>
                    `;
                    chatAttachmentsPreviewContainer.appendChild(attachmentDiv);
                });
                createIcons(); // Re-render icons for new attachments
            } else {
                chatAttachmentsPreviewContainer.classList.add('hidden');
            }
        }

        // Event listener for removing individual chat attachments (using event delegation)
        chatAttachmentsPreviewContainer.addEventListener('click', (event) => {
            const removeBtn = event.target.closest('.remove-attachment-btn');
            if (removeBtn) {
                const attachmentDiv = removeBtn.closest('[data-index]');
                if (attachmentDiv) {
                    const index = parseInt(attachmentDiv.dataset.index);
                    chatAttachments.splice(index, 1); // Remove from array
                    displayChatAttachments(); // Re-render preview
                    chatInput.focus();
                }
            }
        });
        
        // Event listener for sending chat messages
        sendChatBtn.addEventListener('click', async () => {
            const userMessage = chatInput.value.trim();
            if (!userMessage && chatAttachments.length === 0) {
                return;
            }
            
            // Stop speech recognition if active before sending
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }

            // Hide dropdown if open
            chatActionsDropdown.classList.add('hidden');

            // Build the parts for the user message
            const userParts = [];
            if (userMessage) {
                userParts.push({ text: userMessage });
            }
            for (const attachment of chatAttachments) {
                userParts.push({
                    inlineData: {
                        mimeType: attachment.mimeType,
                        data: attachment.data
                    }
                });
            }

            // Append user message and attachments to chat history and UI
            chatHistory.push({ role: 'user', parts: userParts });
            appendChatMessage('user', userMessage, chatAttachments);
            
            // Clear input and attachment after sending
            chatInput.value = '';
            chatAttachments = [];
            chatImageUpload.value = ''; // Clear file input
            displayChatAttachments(); // Clear attachment previews
            
            sendChatBtn.disabled = true;
            
            // Show loading indicator
            const loadingMessage = document.createElement('div');
            loadingMessage.id = 'chat-loading';
            loadingMessage.classList.add('p-4', 'text-center', 'text-gray-500', 'text-sm');
            loadingMessage.innerHTML = `
                <div class="loader-container h-8">
                    <div class="loader-dot bg-gray-500"></div>
                    <div class="loader-dot bg-gray-500"></div>
                    <div class="loader-dot bg-gray-500"></div>
                </div>
                <span class="mt-2 block">AI is typing...</span>
            `;
            chatHistoryDiv.appendChild(loadingMessage);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            try {
                // Call API with full chat history
                const payload = {
                    contents: chatHistory,
                };
                
                const responseText = await callGeminiAPI(payload);
                
                // Append AI response to chat history and UI
                chatHistory.push({ role: 'model', parts: [{ text: responseText }] });
                appendChatMessage('ai', responseText);
                
            } catch (error) {
                console.error('Chat API call failed:', error);
                showError(`An error occurred in the chat: ${error.message}`);
            } finally {
                sendChatBtn.disabled = false;
                const loadingDiv = document.getElementById('chat-loading');
                if (loadingDiv) {
                    loadingDiv.remove();
                }
                chatInput.focus();
            }
        });
        
        // Add event listener for the 'Enter' key on the chat input
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChatBtn.click();
            }
        });

        // Event listener for voice input button (now inside dropdown)
        voiceInputBtn.addEventListener('click', () => {
            if (recognition) {
                if (isVoiceInputActive) {
                    recognition.stop(); // Manually stop recognition
                } else {
                    finalTranscript = ''; // Reset transcript when starting a new session
                    recognition.start();
                }
            } else {
                showError('Speech recognition is not supported in this browser.');
            }
        });

        // Event listener for the new "Add" button to toggle dropdown
        addChatAttachmentBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent document click from immediately closing it
            chatActionsDropdown.classList.toggle('hidden');
            createIcons(); // Ensure icons within dropdown are rendered
        });

        // Close dropdown when clicking anywhere else on the document
        document.addEventListener('click', (event) => {
            if (!chatActionsDropdown.contains(event.target) && !addChatAttachmentBtn.contains(event.target)) {
                chatActionsDropdown.classList.add('hidden');
            }
        });

        // Drag and Drop for Chat Window
        chatPopupWindow.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatPopupWindow.classList.add('drag-over-active');
        });

        chatPopupWindow.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatPopupWindow.classList.remove('drag-over-active');
        });

        chatPopupWindow.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatPopupWindow.classList.remove('drag-over-active');

            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                for (const file of files) {
                    // Basic file type validation for chat (allow images, text, pdf, csv, json, xml, md)
                    const allowedTypes = [
                        'image/', 'text/', 'application/pdf',
                        'application/json', 'text/csv', 'application/xml', 'text/markdown'
                    ];
                    const isAllowed = allowedTypes.some(type => file.type.startsWith(type)) || file.name.endsWith('.md');

                    if (isAllowed) {
                        try {
                            const { mimeType, data } = await fileToBase64(file);
                            chatAttachments.push({ file, mimeType, data, name: file.name });
                        } catch (error) {
                            showError(`Failed to read chat file ${file.name}.`);
                            console.error('Chat file read error:', error);
                        }
                    } else {
                        showError(`File type not supported for chat: ${file.name} (${file.type}).`);
                    }
                }
                displayChatAttachments();
                chatInput.focus();
            }
        });


        // Event listener for the Clear button
        clearBtn.addEventListener('click', () => {
            imageUpload.value = ''; // Reset the file input
            uploadedMainImages = []; // Clear main images
            displayMainImagePreviews(); // Clear the image previews
            
            predictionOutput.innerHTML = ''; // Clear the output text
            resultsContainer.classList.add('hidden');
            exportButtons.classList.add('hidden');
            analyzeBtn.disabled = true;
            
            errorContainer.classList.add('hidden');
            errorText.textContent = '';
            chatToggleButton.classList.remove('hidden'); // Keep chat button visible
            chatPopupWindow.classList.add('chat-hidden'); // Hide chat popup
            chatHistory = []; // Clear chat history
            chatHistoryDiv.innerHTML = '';
            messageTextCache.clear(); // Clear message text cache
            lastPredictionText = ''; // Clear the last prediction text
            
            // Clear chat-specific attachments
            chatAttachments = [];
            chatImageUpload.value = '';
            displayChatAttachments(); // Clear attachment previews
            chatActionsDropdown.classList.add('hidden'); // Hide dropdown

            // Stop any ongoing speech
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                currentUtterance = null;
            }
            // Stop speech recognition if active
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }
        });

        // Floating chat popup toggle logic
        chatToggleButton.addEventListener('click', () => {
            chatPopupWindow.classList.remove('chat-hidden');
            chatPopupWindow.classList.add('chat-visible');
            chatInput.focus();
            setTimeout(createIcons, 50); 
        });

        chatCloseButton.addEventListener('click', () => {
            chatPopupWindow.classList.remove('chat-visible');
            chatPopupWindow.classList.add('chat-hidden');
            chatActionsDropdown.classList.add('hidden'); // Hide dropdown when chat closes

            // Stop any ongoing speech when closing chat
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                currentUtterance = null;
                // Reset all dictate buttons to play state
                document.querySelectorAll('.dictate-message-btn').forEach(btn => {
                    updateButtonIcon(btn, 'volume-2'); // Reset icon
                });
            }
            // Stop speech recognition if active
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }
        });
        
        // Function to show a temporary message for clipboard copy
        function showCopyMessage() {
            copyMessage.classList.add('show');
            setTimeout(() => {
                copyMessage.classList.remove('show');
            }, 3000);
        }

        // Event listener for Save as PDF button
        savePdfBtn.addEventListener('click', async () => {
            if (!window.jspdf || !window.html2canvas) {
                showError('PDF libraries not loaded. Please try again.');
                return;
            }
            if (!lastPredictionText) {
                showError('No prediction available to export to PDF.');
                return;
            }

            const { jsPDF } = window.jspdf;
            
            // Prepare the hidden PDF template content
            pdfBody.innerHTML = marked.parse(lastPredictionText);
            pdfDate.textContent = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            
            // Show the hidden div temporarily for html2canvas to render it with its specific styles
            pdfExportContent.style.display = 'flex'; // Use flex to activate header/footer layout
            // Ensure icons within the PDF template are rendered before html2canvas capture
            createIcons(); 
            
            // Disable buttons during PDF generation
            savePdfBtn.disabled = true;
            shareTextBtn.disabled = true;

            try {
                const canvas = await html2canvas(pdfExportContent, {
                    scale: 2, // Higher scale for better quality
                    useCORS: true,
                    // These options ensure the canvas captures the full scrollable content
                    windowWidth: pdfExportContent.offsetWidth, 
                    windowHeight: pdfExportContent.scrollHeight 
                });

                const imgData = canvas.toDataURL('image/png');
                const imgWidth = canvas.width;
                const imgHeight = canvas.height;

                const pdf = new jsPDF('p', 'mm', 'a4');
                const pdfPageWidth = pdf.internal.pageSize.getWidth(); // A4 width in mm (210mm)
                const pdfPageHeight = pdf.internal.pageSize.getHeight(); // A4 height in mm (297mm)

                // Calculate aspect ratio to fit image width to PDF page width
                const imgAspectRatio = imgWidth / imgHeight;
                let finalImgWidth = pdfPageWidth;
                let finalImgHeight = pdfPageWidth / imgAspectRatio; // This is the height the image would be if it fit the width

                let heightLeft = imgHeight; // Remaining height of the canvas image to be put into PDF (in canvas pixels)
                let position = 0; // Current vertical position in canvas image (in canvas pixels)

                let pageNumber = 1;

                while (heightLeft > 0) {
                    // Add a new page if it's not the first one
                    if (position > 0) {
                        pdf.addPage();
                        pageNumber++;
                    }

                    // Calculate the portion of the canvas image that fits one PDF page
                    // clipHeightPx is the height in the *original canvas pixels* that should be rendered on this PDF page.
                    const clipHeightPx = Math.min(heightLeft, imgHeight * (pdfPageHeight / finalImgHeight));
                    
                    // Add the slice of the image to the PDF
                    // addImage(imageData, format, x, y, width, height, alias, compression, rotation, sx, sy, sWidth, sHeight)
                    // The sx, sy, sWidth, sHeight parameters define the source rectangle on the canvas
                    pdf.addImage(imgData, 'PNG', 0, 0, finalImgWidth, pdfPageHeight, null, 'FAST', 0, 0, imgWidth, position, imgWidth, clipHeightPx);
                    
                    // Add page number at the bottom center
                    pdf.setFontSize(10);
                    pdf.setTextColor(150); // Gray color
                    pdf.text(`Page ${pageNumber}`, pdfPageWidth / 2, pdfPageHeight - 10, { align: 'center' });

                    heightLeft -= clipHeightPx;
                    position += clipHeightPx;
                }
                
                pdf.save('Dream11_Team_Prediction.pdf');
            } catch (error) {
                console.error('Error generating PDF:', error);
                showError('Failed to generate PDF. Please try again.');
            } finally {
                // Hide the template div again
                pdfExportContent.style.display = 'none';
                savePdfBtn.disabled = false;
                shareTextBtn.disabled = false;
            }
        });
        
        // Event listener for Share as Text button
        shareTextBtn.addEventListener('click', () => {
            if (lastPredictionText) {
                const textToCopy = lastPredictionText.trim();
                
                // Copy to clipboard
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = textToCopy;
                document.body.appendChild(tempTextArea);
            
                // Select and copy
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(textToCopy)
                        .then(() => {
                            showCopyMessage();
                        })
                        .catch(err => {
                            console.error('Failed to copy text (Clipboard API):', err);
                            tempTextArea.select();
                            try {
                                document.execCommand('copy'); // Fallback to deprecated method
                                showCopyMessage();
                            } catch (fallbackErr) {
                                console.error('Failed to copy text (execCommand fallback):', fallbackErr);
                                showError('Failed to copy text. Please copy manually.');
                            }
                        });
                } else {
                    tempTextArea.select();
                    try {
                        document.execCommand('copy'); // Fallback to deprecated method
                        showCopyMessage();
                    } catch (err) {
                        console.error('Failed to copy text (execCommand):', err);
                        showError('Failed to copy text. Please copy manually.');
                    }
                }
                document.body.removeChild(tempTextArea);
            } else {
                showError('No team prediction to share yet.');
            }
        });

        // Event delegation for copy code buttons within chat history
        chatHistoryDiv.addEventListener('click', (event) => {
            // Handle code block copy button
            const codeCopyButton = event.target.closest('.code-block-copy-button');
            if (codeCopyButton) {
                const targetId = codeCopyButton.dataset.copyTarget;
                const codeElement = document.getElementById(targetId);
                if (codeElement) {
                    const codeToCopy = codeElement.textContent;
                    // For code block copy button, its own icon changes
                    updateButtonIcon(codeCopyButton, 'check', 'w-4 h-4'); // Explicitly pass classList for code buttons
                    copyToClipboard(codeToCopy); 
                    setTimeout(() => { // Reset icon after 2 seconds
                        updateButtonIcon(codeCopyButton, 'clipboard', 'w-4 h-4'); // Explicitly pass classList
                    }, 2000);
                    return; // Prevent further bubbling for this button
                }
            }

            // Handle chat message copy button
            const chatCopyButton = event.target.closest('.copy-message-btn');
            if (chatCopyButton) {
                const messageId = chatCopyButton.dataset.messageId;
                const messageContent = messageTextCache.get(messageId);
                if (messageContent) {
                    // For chat message copy button, its own icon changes
                    updateButtonIcon(chatCopyButton, 'check');
                    copyToClipboard(messageContent); 
                    setTimeout(() => { // Reset icon after 2 seconds
                        updateButtonIcon(chatCopyButton, 'clipboard');
                    }, 2000);
                } else {
                    showError('Message content not found for copying.');
                }
                return; // Prevent further bubbling
            }

            // Handle dictate message button
            const dictateButton = event.target.closest('.dictate-message-btn');
            if (dictateButton) {
                const messageId = dictateButton.dataset.messageId;
                const messageContent = messageTextCache.get(messageId);
                if (messageContent) {
                    toggleSpeech(messageContent, dictateButton);
                } else {
                    showError('Message content not found for dictation.');
                }
                return; // Prevent further bubbling
            }
        });

        // Helper function to copy text to clipboard
        function copyToClipboard(text) { 
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showCopyMessage();
                    })
                    .catch(err => {
                        console.error('Failed to copy: ', err);
                        showError('Failed to copy text. Please copy manually.');
                    });
            } else {
                // Fallback for older browsers
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = text;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                try {
                    document.execCommand('copy');
                    showCopyMessage();
                } catch (err) {
                    console.error('Failed to copy (fallback):', err);
                    showError('Failed to copy text. Please copy manually.');
                }
                document.body.removeChild(tempTextArea);
            }
        }

        // Helper function for text-to-speech
        function toggleSpeech(text, buttonElement) {
            if (!window.speechSynthesis) {
                showError('Speech synthesis not supported in this browser.');
                return;
            }

            // Check if this specific message is currently being spoken
            if (isSpeaking && currentUtterance && currentUtterance.text === text) {
                // If the same message is currently being spoken, toggle pause/resume
                if (window.speechSynthesis.paused) {
                    window.speechSynthesis.resume();
                    updateButtonIcon(buttonElement, 'pause');
                } else {
                    window.speechSynthesis.pause();
                    updateButtonIcon(buttonElement, 'volume-2');
                }
            } else {
                // If a different message is speaking, or nothing is speaking, start new speech
                startSpeech(text, buttonElement);
            }
        }

        function startSpeech(text, buttonElement) {
            // Cancel any existing speech first
            if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
                window.speechSynthesis.cancel();
            }

            // Reset all other dictate buttons to play state
            document.querySelectorAll('.dictate-message-btn').forEach(btn => {
                if (btn !== buttonElement) { // Don't reset the button that initiated the current speech
                    updateButtonIcon(btn, 'volume-2'); 
                }
            });

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US'; // Set language

            utterance.onstart = () => {
                isSpeaking = true;
                currentUtterance = utterance;
                updateButtonIcon(buttonElement, 'pause');
            };
            utterance.onend = () => {
                isSpeaking = false;
                currentUtterance = null;
                updateButtonIcon(buttonElement, 'volume-2');
            };
            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                showError('Failed to dictate message. Check console for details.');
                isSpeaking = false;
                currentUtterance = null;
                updateButtonIcon(buttonElement, 'volume-2');
            };

            window.speechSynthesis.speak(utterance);
        }


        // Generic API call function with exponential backoff
        async function callGeminiAPI(payload) {
            // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            // IMPORTANT: Replace "YOUR_GEMINI_API_KEY" with your actual Google Gemini API Key.
            // Get your API key from Google AI Studio: https://makersuite.google.com/
            // Do NOT expose your API key directly in production applications.
            // For production, consider using a backend proxy to secure your API key.
            // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            const apiKey = "AIzaSyCzx6ReMk8ohPJcCjGwHHzu7SvFccJqAbA"; 

            if (apiKey === "YOUR_GEMINI_API_KEY" || !apiKey || apiKey === "") { 
                throw new Error("API Key is not set or is the default placeholder. Please replace 'YOUR_GEMINI_API_KEY' in the script with your actual Gemini API key.");
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            let response;
            let result;
            let success = false;
            let retryCount = 0;
            const maxRetries = 3;
            let delay = 1000; // 1 second initial delay

            while (retryCount < maxRetries && !success) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429) { // Too many requests
                        if (retryCount < maxRetries - 1) {
                            console.warn(`API rate limit exceeded. Retrying in ${delay / 1000}s...`);
                            await new Promise(res => setTimeout(res, delay));
                            delay *= 2; // Exponential backoff
                            retryCount++;
                        } else {
                            throw new Error('API rate limit exceeded. Please try again later.');
                        }
                    } else if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
                    } else {
                        result = await response.json();
                        success = true;
                    }
                } catch (err) {
                    if (retryCount < maxRetries - 1) {
                        console.warn(`Fetch error: ${err.message}. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                        retryCount++;
                    } else {
                        throw err; // Re-throw the last error after max retries
                    }
                }
            }
            
            if (result && result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                // Return the text content from the response
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error('Failed to get a valid response from the AI. No candidates found or content is empty.');
            }
        }
    </script>
</body>
</html>

--- END FILE: index.html ---

--- START FILE: manifest.json ---

{
  "name": "Dream11 Team Predictor",
  "short_name": "Dream11 AI",
  "description": "AI-powered Dream11 cricket team prediction and fantasy sports guidance.",
  "start_url": "./",
  "display": "standalone",
  "background_color": "#0a0a0f",
  "theme_color": "#1e88e5",
  "orientation": "portrait",
  "icons": [
    {
      "src": "logo.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "logo.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "logo.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "logo.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}

--- END FILE: manifest.json ---

--- START FILE: sw.js ---

const CACHE_NAME = 'dream11-predictor-v1';
const urlsToCache = [
    './',
    './index.html',
    './manifest.json',
    './logo.png',     // MAKE SURE YOU CREATE THIS FILE
    './favicon.ico',  // MAKE SURE YOU CREATE THIS FILE
    'https://cdn.tailwindcss.com',
    'https://cdn.jsdelivr.net/npm/marked/marked.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js',
    'https://cdn.jsdelivr.net/npm/lucide-dynamic@latest/dist/lucide.min.js',
    'https://unpkg.com/lucide@latest'
];

self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then((cache) => {
                console.log('Opened cache');
                return cache.addAll(urlsToCache);
            })
    );
});

self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request)
            .then((response) => {
                // Cache hit - return response
                if (response) {
                    return response;
                }
                // Clone the request to make a network request
                const fetchRequest = event.request.clone();

                return fetch(fetchRequest).then(
                    (response) => {
                        // Check if we received a valid response
                        if (!response || response.status !== 200 || response.type !== 'basic') {
                            return response;
                        }

                        // Clone the response. A response is a stream
                        // and can only be consumed once.
                        const responseToCache = response.clone();

                        caches.open(CACHE_NAME)
                            .then((cache) => {
                                cache.put(event.request, responseToCache);
                            });

                        return response;
                    }
                );
            })
    );
});

// Optional: Clean up old caches
self.addEventListener('activate', (event) => {
    const cacheWhitelist = [CACHE_NAME];
    event.waitUntil(
        caches.keys().then((cacheNames) => {
            return Promise.all(
                cacheNames.map((cacheName) => {
                    if (cacheWhitelist.indexOf(cacheName) === -1) {
                        return caches.delete(cacheName);
                    }
                })
            );
        })
    );
});

--- END FILE: sw.js ---
